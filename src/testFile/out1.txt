class			KEY_CLASS
WhatHappen			IDENTIFIER
{			LBRACES
public			KEY_PUBLIC
static			KEY_STATIC
void			KEY_VOID
main			KEY_MAIN
(			LPAREN
String			IDENTIFIER
[			LBRACKET
]			RBRACKET
args			IDENTIFIER
)			RPAREN
{			LBRACES
MyClient			IDENTIFIER
mc			IDENTIFIER
;			SEMICOLON
int			KEY_INT
handle			IDENTIFIER
;			SEMICOLON
mc			IDENTIFIER
=			ASSIGN
new			KEY_NEW
MyClient			IDENTIFIER
(			LPAREN
)			RPAREN
;			SEMICOLON
while			KEY_WHILE
(			LPAREN
!			LOGICAL_NOT
false			KEY_FALSE
)			RPAREN
{			LBRACES
handle			IDENTIFIER
=			ASSIGN
mc			IDENTIFIER
.			POINT
start			IDENTIFIER
(			LPAREN
10			INTEGERLITERAL
,			COMMA
10			INTEGERLITERAL
)			RPAREN
;			SEMICOLON
}			RBRACES
}			RBRACES
}			RBRACES
class			KEY_CLASS
Client			IDENTIFIER
{			LBRACES
int			KEY_INT
in			IDENTIFIER
;			SEMICOLON
int			KEY_INT
out			IDENTIFIER
;			SEMICOLON
int			KEY_INT
[			LBRACKET
]			RBRACKET
messagelist			IDENTIFIER
;			SEMICOLON
int			KEY_INT
index			IDENTIFIER
;			SEMICOLON
public			KEY_PUBLIC
boolean			KEY_BOOLEAN
init			IDENTIFIER
(			LPAREN
)			RPAREN
{			LBRACES
get nextToken error! Find illegal character _ At line 19, column 9
_index			ILLEGAL_TOKEN
=			ASSIGN
0			INTEGERLITERAL
;			SEMICOLON
messagelist			IDENTIFIER
=			ASSIGN
new			KEY_NEW
int			KEY_INT
[			LBRACKET
10			INTEGERLITERAL
]			RBRACKET
;			SEMICOLON
in			IDENTIFIER
=			ASSIGN
0			INTEGERLITERAL
;			SEMICOLON
out			IDENTIFIER
=			ASSIGN
0			INTEGERLITERAL
;			SEMICOLON
return			KEY_RETURN
true			KEY_TRUE
;			SEMICOLON
}			RBRACES
public			KEY_PUBLIC
int			KEY_INT
run			IDENTIFIER
(			LPAREN
int			KEY_INT
host			IDENTIFIER
,			COMMA
int			KEY_INT
port			IDENTIFIER
)			RPAREN
{			LBRACES
int			KEY_INT
handle			IDENTIFIER
;			SEMICOLON
handle			IDENTIFIER
=			ASSIGN
this			IDENTIFIER
.			POINT
Juggling			IDENTIFIER
(			LPAREN
)			RPAREN
;			SEMICOLON
}			RBRACES
public			KEY_PUBLIC
int			KEY_INT
getMsg			IDENTIFIER
(			LPAREN
)			RPAREN
{			LBRACES
int			KEY_INT
tmp			IDENTIFIER
;			SEMICOLON
tmp			IDENTIFIER
=			ASSIGN
messagelist			IDENTIFIER
.			POINT
length			KEY_LENGTH
;			SEMICOLON
if			KEY_IF
(			LPAREN
this			IDENTIFIER
.			POINT
isVoid			IDENTIFIER
(			LPAREN
)			RPAREN
)			RPAREN
{			LBRACES
tmp			IDENTIFIER
=			ASSIGN
tmp			IDENTIFIER
-			MINUS
1			INTEGERLITERAL
;			SEMICOLON
}			RBRACES
else			KEY_ELSE
{			LBRACES
tmp			IDENTIFIER
=			ASSIGN
tmp			IDENTIFIER
*			TIMES
2			INTEGERLITERAL
;			SEMICOLON
}			RBRACES
if			KEY_IF
(			LPAREN
index			IDENTIFIER
<			LESS
10			INTEGERLITERAL
)			RPAREN
{			LBRACES
messagelist			IDENTIFIER
[			LBRACKET
index			IDENTIFIER
]			RBRACKET
=			ASSIGN
tmp			IDENTIFIER
;			SEMICOLON
index			IDENTIFIER
=			ASSIGN
index			IDENTIFIER
+			PLUS
1			INTEGERLITERAL
;			SEMICOLON
}			RBRACES
else			KEY_ELSE
{			LBRACES
index			IDENTIFIER
=			ASSIGN
0			INTEGERLITERAL
;			SEMICOLON
}			RBRACES
return			KEY_RETURN
tmp			IDENTIFIER
;			SEMICOLON
}			RBRACES
public			KEY_PUBLIC
boolean			KEY_BOOLEAN
isVoid			IDENTIFIER
(			LPAREN
)			RPAREN
{			LBRACES
boolean			KEY_BOOLEAN
flag			IDENTIFIER
;			SEMICOLON
if			KEY_IF
(			LPAREN
messagelist			IDENTIFIER
.			POINT
length			KEY_LENGTH
get nextToken error! Find illegal character > At line 52, column 31
>			ILLEGAL_TOKEN
0			INTEGERLITERAL
)			RPAREN
{			LBRACES
flag			IDENTIFIER
=			ASSIGN
false			KEY_FALSE
;			SEMICOLON
}			RBRACES
else			KEY_ELSE
{			LBRACES
flag			IDENTIFIER
=			ASSIGN
true			KEY_TRUE
;			SEMICOLON
}			RBRACES
return			KEY_RETURN
flag			IDENTIFIER
;			SEMICOLON
}			RBRACES
public			KEY_PUBLIC
int			KEY_INT
Juggling			IDENTIFIER
(			LPAREN
)			RPAREN
{			LBRACES
boolean			KEY_BOOLEAN
t			IDENTIFIER
;			SEMICOLON
int			KEY_INT
tmp1			IDENTIFIER
;			SEMICOLON
int			KEY_INT
tmp2			IDENTIFIER
;			SEMICOLON
int			KEY_INT
tmp3			IDENTIFIER
;			SEMICOLON
tmp1			IDENTIFIER
=			ASSIGN
2			INTEGERLITERAL
;			SEMICOLON
tmp2			IDENTIFIER
=			ASSIGN
3			INTEGERLITERAL
;			SEMICOLON
tmp3			IDENTIFIER
=			ASSIGN
4			INTEGERLITERAL
;			SEMICOLON
while			KEY_WHILE
(			LPAREN
(			LPAREN
tmp2			IDENTIFIER
<			LESS
tmp3			IDENTIFIER
)			RPAREN
get nextToken error! Find illegal character & At line 69
&			ILLEGAL_TOKEN
(			LPAREN
tmp1			IDENTIFIER
<			LESS
tmp2			IDENTIFIER
)			RPAREN
)			RPAREN
{			LBRACES
tmp1			IDENTIFIER
=			ASSIGN
tmp3			IDENTIFIER
-			MINUS
tmp2			IDENTIFIER
;			SEMICOLON
tmp2			IDENTIFIER
=			ASSIGN
tmp2			IDENTIFIER
-			MINUS
tmp1			IDENTIFIER
;			SEMICOLON
tmp3			IDENTIFIER
=			ASSIGN
tmp2			IDENTIFIER
*			TIMES
tmp1			IDENTIFIER
;			SEMICOLON
t			IDENTIFIER
=			ASSIGN
this			IDENTIFIER
.			POINT
HolyLight			IDENTIFIER
(			LPAREN
)			RPAREN
;			SEMICOLON
}			RBRACES
return			KEY_RETURN
(			LPAREN
tmp1			IDENTIFIER
*			TIMES
tmp2			IDENTIFIER
+			PLUS
tmp3			IDENTIFIER
)			RPAREN
*			TIMES
messagelist			IDENTIFIER
.			POINT
length			KEY_LENGTH
;			SEMICOLON
}			RBRACES
public			KEY_PUBLIC
boolean			KEY_BOOLEAN
HolyLight			IDENTIFIER
(			LPAREN
)			RPAREN
{			LBRACES
in			IDENTIFIER
=			ASSIGN
in			IDENTIFIER
+			PLUS
1			INTEGERLITERAL
;			SEMICOLON
out			IDENTIFIER
=			ASSIGN
out			IDENTIFIER
-			MINUS
1			INTEGERLITERAL
;			SEMICOLON
System.out.println			KEY_PRINTLIN
(			LPAREN
false			KEY_FALSE
)			RPAREN
;			SEMICOLON
}			RBRACES
}			RBRACES
class			KEY_CLASS
MyClient			IDENTIFIER
extend			IDENTIFIER
Client			IDENTIFIER
{			LBRACES
public			KEY_PUBLIC
int			KEY_INT
start			IDENTIFIER
(			LPAREN
int			KEY_INT
host			IDENTIFIER
,			COMMA
int			KEY_INT
port			IDENTIFIER
)			RPAREN
{			LBRACES
int			KEY_INT
handle			IDENTIFIER
;			SEMICOLON
handle			IDENTIFIER
=			ASSIGN
this			IDENTIFIER
.			POINT
run			IDENTIFIER
(			LPAREN
)			RPAREN
return			KEY_RETURN
handle			IDENTIFIER
;			SEMICOLON
}			RBRACES
}			RBRACES
